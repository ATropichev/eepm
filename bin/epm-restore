#!/bin/sh
#
# Copyright (C) 2020  Etersoft
# Copyright (C) 2020  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

load_helper epm-sh-altlinux
load_helper epm-assure

# FIXME: python modules are packaged into python packages, but we have only module names and rpm package names instead of python packages
__epm_filter_pip_to_rpm()
{
    tr "A-Z" "a-z" | sed -e "s|-|_|g" -e "s|^python_||" \
        -e "s|beautifulsoup4|bs4|" \
        -e "s|pillow|PIL|" \
        -e "s|pyjwt|jwt|" \
        -e "s|pyyaml|yaml|" \
        -e "s|attrs|attr|" \
        -e "s|pygments|Pygments|" \
        -e "s|patch_ng|patch-ng|" \
        -e "s|memcached|memcache|" \
        -e "s|pyopenssl|OpenSSL|"
}

# TODO: remove me
fill_sign()
{
    local sign="$1"
    echo "$2" | grep -E -- "$sign[[:space:]]*[0-9.]+?" | sed -E -- "s|.*$sign[[:space:]]*([0-9.]+?).*|\1|"
}


__epm_restore_pip()
{
    local req_file="$1"
    [ -n "$dryrun" ] || info "Install requirements from $req_file ..."

    local ilist=''
    while read l ; do
        local t="$(echo "$l" | sed -e "s| *[<>!]*=.*||" -e "s| *#.*||" | __epm_filter_pip_to_rpm)"
        if echo "$l" | grep -qE "^ *#" || [ -z "$l" ] ; then
            continue
        fi
        # until new section
        if echo "$l" | grep -qE "^\[" ; then
            break
        fi
        # if dependency_links URLs, use egg name
        if echo "$l" | grep -qE "://" ; then
            if echo "$l" | grep -q "#egg=" ; then
                t="$(echo "$l" | sed -e "s|.*#egg=||" -e "s|\[.*||" | __epm_filter_pip_to_rpm)"
            else
                echo "    skipping URL $l ..."
                continue
            fi
        fi
        if echo "$l" | grep -q "; *python_version *< *'3.0'" ; then
            echo "    $t is python2 only requirement, skipped"
            continue
        fi
        if [ -n "$dryrun" ] ; then
            local pi=''
            local sign ll
            for sign in "<=" "<" ">=" ">" "==" "!="; do
                ll=$(fill_sign "$sign" "$l")
                [ -n "$ll" ] || continue
[ "$sign" = "==" ] && sign="="
[ "$sign" = "!=" ] && sign=">="
                pi="$pi
%py3_use $t $sign $ll"
            done
            [ -n "$pi" ] || pi="%py3_use $t"
            echo "$pi"
            continue
        else
            # TODO: python3-egg-info($t)
            local pi="python3($t)"
            echo "    $l -> $t -> $pi"
        fi
        [ -n "$t" ] || continue
        ilist="$ilist $pi"
    done < $req_file

    if [ -n "$dryrun" ] ; then
        echo "$ilist"
        return
   fi

    docmd epm install $ilist
}

__epm_restore_by()
{
    local req_file="$1"
    [ -s "$req_file" ] || return

    if file $req_file | grep -q "ELF [3264]*-bit LSB executable" ; then
        assure_exists ldd-requires
        showcmd ldd-requires $req_file
        local TOINSTALL="$(a= ldd-requires $req_file | grep "^apt-get install" | sed -e "s|^apt-get install ||")"
        if [ -n "$dryrun" ] ; then
            estrlist list $TOINSTALL
            return
        fi
        [ -n "$TOINSTALL" ] || { info "There are no missed packages is found for $req_file binary." ; return ; }
        docmd epm install $TOINSTALL
        return
    fi

    case $(basename $req_file) in
        requirements.txt|requires.txt)
            [ -s "$req_file" ] && __epm_restore_pip "$req_file"
            ;;
        Gemfile|package.json)
            info "$req_file support is not implemented yet"
            ;;
    esac
}

epm_restore()
{
    req_file="$pkg_filenames"
    if [ -n "$pkg_urls" ] && echo "$pkg_urls" | grep -qE "^https?://" ; then
        req_file="$(basename "$pkg_urls")"
        #assure eget
        [ -r "$req_file" ] && fatal "File $req_file is already exists in $(pwd)"
        info "Downloading '$req_file' from '$pkg_urls' ..."
        eget "$pkg_urls"
        [ -s "$req_file" ] || fatal "Can't download $req_file from '$pkg_urls'"
    fi

    if [ -n "$req_file" ] ; then
        __epm_restore_by $req_file
        return
    fi

    # if run with empty args
    for i in requirements.txt Gemfile requires.txt; do
        __epm_restore_by $i
    done

}
