#!/bin/sh
#
# Copyright (C) 2020  Etersoft
# Copyright (C) 2020  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

load_helper epm-sh-altlinux
load_helper epm-assure

# FIXME: python modules are packaged into python packages, but we have only module names and rpm package names instead of python packages
# enable python3dest(PEP-503 normalized name) provides
# https://bugzilla.altlinux.org/show_bug.cgi?id=39003
__epm_filter_pip_to_rpm()
{
    tr "A-Z" "a-z" | sed -e "s|-|_|g" -e "s|^python_||" \
        -e "s|beautifulsoup4|bs4|" \
        -e "s|pillow|PIL|" \
        -e "s|redis|redis-py|" \
        -e "s|pyjwt|jwt|" \
        -e "s|pyyaml|yaml|" \
        -e "s|attrs|attr|" \
        -e "s|pygments|Pygments|" \
        -e "s|patch_ng|patch-ng|" \
        -e "s|memcached|memcache|" \
        -e "s|pyopenssl|OpenSSL|"
}

# TODO: remove me
fill_sign()
{
    local sign="$1"
    echo "$2" | grep -E -- "$sign[[:space:]]*[0-9.]+?" | sed -E -- "s|.*$sign[[:space:]]*([0-9.]+?).*|\1|"
}


# macro pkg caseline
__epm_pi_sign_to_rpm()
{
    local reqmacro="$1"
    local t="$2"
    local l="$3"
    local equal="$4"
    [ -n "$equal" ] || equal="="

    local pi=''
    local sign ll
    for sign in "<=" "<" ">=" ">" "==" "!="; do
        ll=$(fill_sign "$sign" "$l")
        [ -n "$ll" ] || continue
        [ "$sign" = "==" ] && sign="$equal"
        [ "$sign" = "!=" ] && sign=">="
        [ -n "$pi" ] && pi="$pi
"
        pi="$pi$reqmacro $t $sign $ll"
    done
    [ -n "$pi" ] || pi="$reqmacro $t"
    echo "$pi"
}

__epm_restore_pip()
{
    local req_file="$1"
    if [ -n "$dryrun" ] ; then
        echo
        echo "# generated by epm --restore --dry-run from $(basename $(dirname $(realpath $req_file)))/$req_file"
    else
        info "Install requirements from $req_file ..."
    fi

    local ilist=''
    while read l ; do
        local t="$(echo "$l" | sed -e "s| *[<>!]*=.*||" -e "s| *#.*||" | __epm_filter_pip_to_rpm)"
        if echo "$l" | grep -qE "^ *#" || [ -z "$l" ] ; then
            continue
        fi
        # until new section
        if echo "$l" | grep -qE "^\[" ; then
            break
        fi
        # if dependency_links URLs, use egg name
        if echo "$l" | grep -qE "://" ; then
            if echo "$l" | grep -q "#egg=" ; then
                t="$(echo "$l" | sed -e "s|.*#egg=||" -e "s|\[.*||" | __epm_filter_pip_to_rpm)"
            else
                warning "    skipping URL $l ..."
                continue
            fi
        fi
        if echo "$l" | grep -q "; *python_version *< *'3.0'" ; then
            warning "    $t is python2 only requirement, skipped"
            continue
        fi
        [ -n "$t" ] || continue
        if [ -n "$dryrun" ] ; then
            local reqmacro="%py3_use"
            [ "$(basename "$req_file")" = "requirements_dev.txt" ] && reqmacro="%py3_buildrequires"
            __epm_pi_sign_to_rpm $reqmacro $t $l
            continue
        else
            # TODO: python3-egg-info($t)
            local pi="python3($t)"
            echo "    $l -> $t -> $pi"
        fi
        ilist="$ilist $pi"
    done < $req_file

    if [ -n "$dryrun" ] ; then
        echo "$ilist"
        return
    fi

    docmd epm install $ilist
}

__epm_restore_setup_py()
{
    local req_file="$1"
    if [ -z "$dryrun" ] ; then
        info "Install requirements from $req_file ..."
    fi

    local ilist=''
    local fr fd
    local reqmacro
    while read l ; do
        if rhas "$l" "^ *#" ; then
            continue
        fi
        if rhas "$l" "\]," ; then
            fr=''
            fd=''
            continue
        fi
        if [ -n "$fr$fd" ] ; then
            local ll="$(echo "$l" | sed -e "s|[[:space:]]*'||" -e "s|'.*||")"
            local t="$(echo "$ll" | sed -e "s| *[<>!]*=.*||" | __epm_filter_pip_to_rpm)"
            if [ -n "$dryrun" ] ; then
                __epm_pi_sign_to_rpm $reqmacro $t $ll ">="
            else
                local pi="python3-module-$t"
                ilist="$ilist $pi"
                echo "    $l -> $t -> $pi"
            fi
            continue
        fi
        if rhas "$l" "install_requires=\[" ; then
            reqmacro="%py3_use"
            if [ -n "$dryrun" ] ; then
                echo
                echo "# generated by epm --restore --dry-run from $(basename $(dirname $(realpath $req_file)))/$req_file $l"
            fi
            fr=1
            continue
        fi
        if rhas "$l" "tests_require=\[" ; then
            reqmacro="%py3_buildrequires"
            if [ -n "$dryrun" ] ; then
                echo
                echo "# generated by epm --restore --dry-run from $(basename $(dirname $(realpath $req_file)))/$req_file $l"
            fi
            fd=1
            continue
        fi
    done < $req_file

    if [ -n "$dryrun" ] ; then
        echo "$ilist"
        return
    fi

    docmd epm install $ilist
}

__epm_print_npm_list()
{
    local reqmacro="$1"
    local req_file="$2"
    local l
    while read l ; do
        # "tap": "^14.10.7"
        echo "$l" | grep -q '"\(.*\)": "\(.*\)"' || continue
        local name="$(echo "$l" | sed -e 's|.*"\(.*\)": ".*|\1|')"
        [ -z "$name" ] && continue
        local ver="$(echo "$l" | sed -e 's|.*"\(.*\)": "\(.*\)".*|\2|')" #'
        [ -z "$name" ] && continue

        if [ -n "$dryrun" ] ; then
            local pi=''
            local sign
            if echo "$ver" | grep -q "^\^" ; then
                sign=">="
            else
                sign="="
            fi
            ll=$(echo "$ver" | sed -e 's|^[^~]||')
            pi="$pi$reqmacro node-$name $sign $ll"
#         [ -n "$pi" ] && pi="$pi
#"
#           [ -n "$pi" ] || pi="$pi$reqmacro: node-$t"
            echo "$pi"
            continue
        else
            local pi="node-$name"
            #echo "    $l -> $name -> $pi"
        fi
        [ -n "$name" ] || continue
        ilist="$ilist $pi"
    done < $req_file

    [ -n "$dryrun" ] || echo "$ilist"
}

__epm_restore_npm()
{
    local req_file="$1"

    epm assure jq

    if [ -n "$dryrun" ] ; then
        local lt=$(mktemp)
        a= jq .dependencies <$req_file >$lt
        echo
        echo "# generated by epm --restore --dry-run from $(basename $(dirname $(realpath $req_file)))/$req_file"
        __epm_print_npm_list "Requires:" $lt

        echo
        echo "# devDependencies generated by epm --restore --dry-run from $(basename $(dirname $(realpath $req_file)))/$req_file"
        a= jq .devDependencies <$req_file >$lt
        __epm_print_npm_list "BuildRequires:" $lt
        rm -f $lt
        return
    fi

    info "Install requirements from $req_file ..."
    local lt=$(mktemp)
    a= jq .dependencies <$req_file >$lt
    ilist="$(__epm_print_npm_list "" $lt)"
    a= jq .devDependencies <$req_file >$lt
    ilist="$ilist $(__epm_print_npm_list "" $lt)"
    rm -f $lt
    docmd epm install $ilist
}

__epm_restore_by()
{
    local req_file="$1"
    [ -s "$req_file" ] || return

    if file $req_file | grep -q "ELF [3264]*-bit LSB executable" ; then
        assure_exists ldd-requires
        showcmd ldd-requires $req_file
        local TOINSTALL="$(a= ldd-requires $req_file | grep "^apt-get install" | sed -e "s|^apt-get install ||")"
        if [ -n "$dryrun" ] ; then
            estrlist list $TOINSTALL
            return
        fi
        [ -n "$TOINSTALL" ] || { info "There are no missed packages is found for $req_file binary." ; return ; }
        docmd epm install $TOINSTALL
        return
    fi

    case $(basename $req_file) in
        requirements.txt|requirements_dev.txt|requires.txt)
            [ -s "$req_file" ] && __epm_restore_pip "$req_file"
            ;;
        setup.py)
            [ -s "$req_file" ] && __epm_restore_setup_py "$req_file"
            ;;
        package.json)
            [ -s "$req_file" ] && __epm_restore_npm "$req_file"
            ;;
        Gemfile|package.json)
            info "$req_file support is not implemented yet"
            ;;
    esac
}

epm_restore()
{
    req_file="$pkg_filenames"
    if [ -n "$pkg_urls" ] && echo "$pkg_urls" | grep -qE "^https?://" ; then
        req_file="$(basename "$pkg_urls")"
        #assure eget
        [ -r "$req_file" ] && fatal "File $req_file is already exists in $(pwd)"
        info "Downloading '$req_file' from '$pkg_urls' ..."
        eget "$pkg_urls"
        [ -s "$req_file" ] || fatal "Can't download $req_file from '$pkg_urls'"
    fi

    if [ -n "$req_file" ] ; then
        __epm_restore_by $req_file
        return
    fi

# TODO: nowhere works: python3 setup.py --requires

    # if run with empty args
    for i in requirements.txt requirements_dev.txt Gemfile requires.txt package.json setup.py; do
        __epm_restore_by $i
    done

}
