#!/bin/sh
#
# Copyright (C) 2023  Etersoft
# Copyright (C) 2023  Vitaly Lipatov <lav@etersoft.ru>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

load_helper epm-sh-altlinux
load_helper epm-assure
load_helper epm-repack

[ -n "$EPM_PACK_SCRIPTS_DIR" ] || EPM_PACK_SCRIPTS_DIR="$CONFIGDIR/pack.d"


# we run this function in a tmpdir
__epm_pack()
{
    local packname="$1"
    local tarname="$2"
    local packversion="$3"
    returntarname=''

    local repackcode="$EPM_PACK_SCRIPTS_DIR/$packname.sh"
    [ -x "$repackcode" ] || fatal "Can't find script $repackcode for packname $packname"
    [ -f "$repackcode.rpmnew" ] && warning "There is .rpmnew file(s) in $EPM_PACK_SCRIPTS_DIR dir. The pack script can be outdated."

    # a file to keep filename of generated tarball
    filefortarname="$(pwd)/filefortarname"

    set_sudo
    export SUDO

    # TODO: inside () ?
    export PATH=$PROGDIR:$PATH

    local bashopt=''
    [ -n "$verbose" ] && bashopt='-x'
    #info "Running $($script --description 2>/dev/null) ..."
    ( unset EPMCURDIR ; docmd $CMDSHELL $bashopt $repackcode "$tarname" "$filefortarname" "$packversion" ) || fatal
    returntarname="$(cat "$filefortarname")" || fatal "pack script $repackcode didn't set tarname"

    [ -s "$returntarname" ] || fatal "pack script $repackcode return unexist $returntarname file"

    if [ -n "$download_only" ] ; then
        mv $returntarname $EPMCURDIR
        return
    fi

    # repack if needed
    repacked_pkgs=''
    # repack to our target
    if __epm_repack_if_needed $returntarname ; then
        [ -n "$repacked_pkgs" ] || fatal "Can't repack $returntarname"
    # if repack is forced or repack rule (not disabled) is exists
    elif [ -n "$repack" ] || [ -z "$norepack" ] && __epm_have_repack_rule $returntarname ; then
        __epm_repack "$returntarname"
        [ -n "$repacked_pkgs" ] || fatal "Can't repack $returntarname"
    fi

    if [ -n "$repacked_pkgs" ] ; then
        # remove packed file if we have repacked one
        rm -v "$returntarname"
        # also drop spaces
        pkgname="$(echo $repacked_pkgs)"
    else
        pkgname="$returntarname"
    fi

    if [ -n "$install" ] ; then
        docmd epm install "$pkgname"
        return
    fi

    # we need put result in the cur dir
    mv -v "$pkgname" $EPMCURDIR || fatal

}

epm_pack_help()
{
    cat <<EOF
epm pack - create rpm package from files
Usage: epm pack [options] <packname> <tar|url|dir> [version]
Options:
    <packname>            - receipt
    <dir>                 - create tarball from the dir before
    <url>                 - download tar from url
    [version]             - force version for unversioned sources
    --install             - install after pack result
    --repack              - force repack ever if returned package can be installed without repack
    --download-only       - save pack result and exit
    --save-only           - save repacked packages and exit (this is default behaviour)
EOF
}


epm_pack()
{

    if [ "$1" = "-h" ] || [ "$1" = "--help" ] ; then
        epm_pack_help
        exit
    fi

    trap "__epm_remove_tmp_files" EXIT
    local tmpdir="$(mktemp -d --tmpdir=$BIGTMPDIR)"
    to_clean_tmp_dirs="$to_clean_tmp_dirs $tmpdir"

    local packname="$1"
    local tarname="$2"
    local packversion="$3"

    [ -n "$packname" ] || fatal "run with packname, see --help"

    if is_url "$tarname"; then
        pkg_urls="$tarname"
        load_helper epm-download
        cd $tmpdir || fatal
        __handle_pkg_urls_to_install
        # drop spaces and get full path
        tarname="$(realpath $pkg_files)"
    elif [ -d "$tarname" ] ; then
        tarname="$(realpath "$tarname")"
        cd $tmpdir || fatal
    elif [ -s "$tarname" ] ; then
        # get full path for real name
        tarname="$(realpath "$tarname")"
        cd $tmpdir || fatal
    else
        # just pass name
        true
    fi

    __epm_pack "$packname" "$tarname" "$packversion"

}
